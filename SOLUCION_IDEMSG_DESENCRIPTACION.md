# üîì Soluci√≥n: Desencriptaci√≥n de `idemsg` en Sistema OTP

## üìã Resumen Ejecutivo

**Problema identificado:** Los c√≥digos OTP (`idemsg`) retornados por la API 2155 vienen encriptados en Base64 desde el backend, pero deben enviarse desencriptados a la API 2156 para validaci√≥n. Esto causaba fallos en todos los flujos que requieren OTP.

**Soluci√≥n implementada:** Desencriptaci√≥n autom√°tica de `idemsg` en la capa de servicios mediante m√©todo helper centralizado, aplicado a 7 m√©todos cr√≠ticos en 3 archivos de servicios.

**Resultado:** Todos los flujos OTP ahora funcionan correctamente (transferencias, 2FA, cambio de contrase√±a, registro de usuarios).

---

## üéØ Alcance de la Soluci√≥n

### Archivos Modificados (3)

1. **`src/services/apiService.js`** (6,262 l√≠neas)
   - ‚úÖ M√©todo helper `decryptIdemsgIfNeeded()` agregado (l√≠neas ~94-125)
   - ‚úÖ 5 m√©todos OTP refactorizados

2. **`src/services/apiserviceTransfer.js`** (1,012 l√≠neas)
   - ‚úÖ M√©todo helper `decryptIdemsgIfNeeded()` agregado
   - ‚úÖ 1 m√©todo OTP refactorizado

3. **`src/services/ApiServiceTransferExt.js`** (865 l√≠neas)
   - ‚úÖ M√©todo helper `decryptIdemsgIfNeeded()` agregado
   - ‚úÖ 1 m√©todo OTP refactorizado

### M√©todos OTP Corregidos (7)

#### apiService.js (5 m√©todos)
1. ‚úÖ **`requestOTPForInternalTransfer()`** - L√≠nea ~5840
   - **Flujo:** Transferencias entre cuentas propias
   - **Context log:** `[INTERNAL-TRANSFER-OTP]`

2. ‚úÖ **`requestSecurityCodeFor2FA()`** - L√≠nea ~5911
   - **Flujo:** Autenticaci√≥n en dos pasos en login
   - **Context log:** `[2FA-OTP]`

3. ‚úÖ **`requestSecurityCodeForPasswordChange()`** - L√≠nea ~1429
   - **Flujo:** Cambio de contrase√±a desde dashboard
   - **Context log:** `[CHANGE-PWD-OTP]`

4. ‚úÖ **`requestSecurityCodeForRegistration()`** - L√≠nea ~1972
   - **Flujo:** Registro de preguntas de seguridad
   - **Context log:** `[SECURITY-REG-OTP]`

5. ‚úÖ **`requestSecurityCodeForUserRegistration()`** - L√≠nea ~2552
   - **Flujo:** Creaci√≥n de nueva cuenta de usuario
   - **Context log:** `[USER-REG-OTP]`

#### apiserviceTransfer.js (1 m√©todo)
6. ‚úÖ **`requestOTPForCoopTransfer()`** - L√≠nea ~473
   - **Flujo:** Transferencias a otros usuarios de CACVIL
   - **Context log:** `[COOP-TRANSFER-OTP]`

#### ApiServiceTransferExt.js (1 m√©todo)
7. ‚úÖ **`requestOTPForExternalTransfer()`** - L√≠nea ~475
   - **Flujo:** Transferencias a otros bancos
   - **Context log:** `[EXTERNAL-TRANSFER-OTP]`

---

## üîß Implementaci√≥n T√©cnica

### ‚ö†Ô∏è DESCUBRIMIENTO CR√çTICO - Doble Encriptaci√≥n

**PROBLEMA IDENTIFICADO POST-IMPLEMENTACI√ìN:**

El `idemsg` estaba siendo **encriptado dos veces**:

1. ‚úÖ Backend (API 2155) retorna `idemsg` encriptado en Base64
2. ‚úÖ Helper `decryptIdemsgIfNeeded()` lo desencripta correctamente
3. ‚ùå **PERO** `encryptRequest()` lo vuelve a encriptar antes de enviar (APIs 2355, 2360, 2160)
4. ‚ùå Backend no lo reconoce ‚Üí Error: "REGISTRO CODIGO SEGURIDAD NO EXISTE"

**SOLUCI√ìN:**
Remover `idemsg` de la lista `encryptFields` en los procesos que lo utilizan:
- ‚úÖ Proceso **2355** (transferencias cooperativas)
- ‚úÖ Proceso **2360** (transferencias externas)
- ‚úÖ Proceso **2160** (cambio contrase√±a/bloqueo)
- ‚úÖ Proceso **2156** (validaci√≥n OTP) - YA estaba correcto

**RAZONAMIENTO:**
- El `idemsg` es un **ID de sesi√≥n OTP** que el backend genera y almacena
- Backend espera recibir el **mismo valor desencriptado** que √©l gener√≥
- NO debe ser re-encriptado al enviarlo de vuelta
- Solo `codseg` (c√≥digo OTP ingresado) debe encriptarse

### M√©todo Helper Centralizado

Se cre√≥ un m√©todo helper reutilizable en cada servicio que maneja la l√≥gica de desencriptaci√≥n:

```javascript
/**
 * üîì HELPER: Desencripta idemsg si viene encriptado desde el backend
 * Centraliza la l√≥gica de desencriptaci√≥n para todos los m√©todos OTP
 * @param {string} idemsg - El valor idemsg recibido del backend
 * @param {string} context - Contexto para logging (ej: 'INTERNAL-TRANSFER-OTP')
 * @returns {string} - El idemsg desencriptado o el original si no est√° encriptado
 */
decryptIdemsgIfNeeded(idemsg, context = 'OTP') {
  if (!idemsg) return idemsg;

  // Detectar si est√° encriptado (Base64 pattern)
  const isEncrypted = /^[A-Za-z0-9+/]*={0,2}$/.test(String(idemsg));
  
  if (isEncrypted && String(idemsg).length > 20) {
    try {
      const { decrypt } = require('@/utils/crypto/encryptionService');
      const decryptedIdemsg = decrypt(idemsg);
      console.log(`üîì [${context}] idemsg desencriptado exitosamente`);
      return decryptedIdemsg;
    } catch (err) {
      console.error(`‚ùå [${context}] Error desencriptando idemsg:`, err);
      // Si falla, retornar el valor original como fallback
      return idemsg;
    }
  }
  
  // No est√° encriptado o es muy corto, retornar tal cual
  return idemsg;
}
```

### Patr√≥n de Uso en M√©todos OTP

**Antes (‚ùå Problema):**
```javascript
if (codeResult.success && result.data.cliente?.[0]?.idemsg) {
  console.log('‚úÖ C√≥digo OTP solicitado exitosamente');
  console.log('üÜî idemsg recibido:', result.data.cliente[0].idemsg);  // ‚ö†Ô∏è Viene encriptado
  
  return {
    success: true,
    data: {
      idemsg: result.data.cliente[0].idemsg,  // ‚ùå Se retorna encriptado
      idecli: result.data.cliente[0].idecli,
      message: result.data.msg || 'C√≥digo de seguridad enviado'
    }
  };
}
```

**Despu√©s (‚úÖ Soluci√≥n):**
```javascript
if (codeResult.success && result.data.cliente?.[0]?.idemsg) {
  console.log('‚úÖ C√≥digo OTP solicitado exitosamente');
  
  // üîì DESENCRIPTAR idemsg usando helper
  const idemsg = this.decryptIdemsgIfNeeded(
    result.data.cliente[0].idemsg, 
    'CONTEXT-NAME-OTP'  // Contexto para logging
  );
  
  console.log('üÜî idemsg procesado');  // ‚úÖ Ya desencriptado
  
  return {
    success: true,
    data: {
      idemsg: idemsg,  // ‚úÖ Se retorna desencriptado
      idecli: result.data.cliente[0].idecli,
      message: result.data.msg || 'C√≥digo de seguridad enviado'
    }
  };
}
```

---

## üîÑ Flujo Completo OTP

### 1. Solicitud de C√≥digo (API 2155)
```
Frontend ‚Üí API Service ‚Üí Backend (2155)
                     ‚Üì
Backend retorna idemsg ENCRIPTADO (Base64)
                     ‚Üì
decryptIdemsgIfNeeded() ‚Üí idemsg DESENCRIPTADO
                     ‚Üì
Frontend recibe idemsg DESENCRIPTADO
```

### 2. Validaci√≥n de C√≥digo (API 2156)
```
Frontend env√≠a:
- idemsg: DESENCRIPTADO (‚úÖ gracias a la soluci√≥n)
- codseg: 123456 (c√≥digo ingresado por usuario)
                     ‚Üì
apiService.makeRequest() ‚Üí encryptRequest()
                     ‚Üì
Sistema de encriptaci√≥n encripta ambos campos:
- idemsgE: Base64(AES(idemsg))  
- codsegE: Base64(AES(codseg))
                     ‚Üì
Backend (2156) recibe campos encriptados
                     ‚Üì
Backend desencripta y valida ‚úÖ
```

---

## üìä Detecci√≥n de Encriptaci√≥n

### Criterios de Detecci√≥n

El helper method usa dos criterios para detectar si un `idemsg` est√° encriptado:

1. **Patr√≥n Base64:** Regex `/^[A-Za-z0-9+/]*={0,2}$/`
   - Solo caracteres: A-Z, a-z, 0-9, +, /
   - Opcionalmente termina con uno o dos signos `=` (padding)

2. **Longitud m√≠nima:** `String(idemsg).length > 20`
   - Los `idemsg` encriptados t√≠picamente tienen >30 caracteres
   - Los desencriptados son num√©ricos cortos (~15 caracteres)

### Ejemplos

**idemsg Encriptado (del backend):**
```
"U2FsdGVkX1+ABC123XYZ789/def456ghi=="  (Base64, 40+ chars) ‚Üí DESENCRIPTAR
```

**idemsg Desencriptado (esperado):**
```
"202501251430001"  (Num√©rico, 15 chars) ‚Üí NO DESENCRIPTAR
```

---

## üõ°Ô∏è Manejo de Errores

### Estrategia Defensiva

El helper method implementa try-catch con fallback:

```javascript
try {
  const { decrypt } = require('@/utils/crypto/encryptionService');
  const decryptedIdemsg = decrypt(idemsg);
  console.log(`üîì [${context}] idemsg desencriptado exitosamente`);
  return decryptedIdemsg;
} catch (err) {
  console.error(`‚ùå [${context}] Error desencriptando idemsg:`, err);
  // Si falla, retornar el valor original como fallback
  return idemsg;
}
```

### Razones de Fallo Posibles

1. **Clave AES incorrecta:** `VITE_AES_KEY` no coincide con backend
2. **IV incorrecto:** `VITE_AES_IV` no coincide con backend
3. **Formato inv√°lido:** No es Base64 v√°lido
4. **Padding incorrecto:** Base64 malformado

En todos los casos, **se retorna el valor original** para evitar crashes y permitir debugging.

---

## üîç Debugging y Logging

### Logs de √âxito

```javascript
console.log('‚úÖ [COOP-TRANSFER] C√≥digo OTP solicitado exitosamente');
console.log('üîì [COOP-TRANSFER-OTP] idemsg desencriptado exitosamente');
console.log('üÜî [COOP-TRANSFER] idemsg procesado');
```

### Logs de Error

```javascript
console.error('‚ùå [COOP-TRANSFER-OTP] Error desencriptando idemsg:', err);
```

### Verificaci√≥n Manual

En consola del navegador:
```javascript
// Ver idemsg encriptado
console.log('Encriptado:', result.data.cliente[0].idemsg);

// Ver idemsg desencriptado
const { decrypt } = require('@/utils/crypto/encryptionService');
console.log('Desencriptado:', decrypt(result.data.cliente[0].idemsg));
```

---

## ÔøΩ Troubleshooting

### Error: "REGISTRO CODIGO SEGURIDAD NO EXISTE"

**S√≠ntoma:**
```javascript
{estado: '001', msg: 'REGISTRO CODIGO SEGURIDAD NO EXISTE'}
```

**Causa:** El `idemsg` est√° siendo encriptado cuando NO deber√≠a.

**Verificaci√≥n:**
1. Abrir consola del navegador
2. Buscar log: `üîê [ENCRYPT_REQUEST] Valores DESPU√âS de encriptaci√≥n`
3. Si ves `idemsg: "xxxxxx=="` (Base64) ‚Üí **PROBLEMA** ‚ùå
4. Debe verse `idemsg: "202501251430001"` (num√©rico) ‚Üí **CORRECTO** ‚úÖ

**Soluci√≥n:**
Verificar que `idemsg` NO est√© en la lista `encryptFields` del proceso en `fieldMapper.js`:
```javascript
// ‚ùå MAL
'2360': {
  encryptFields: ['idecl', 'codseg', 'idemsg']  // ‚Üê REMOVER idemsg
}

// ‚úÖ BIEN
'2360': {
  encryptFields: ['idecl', 'codseg']  // ‚Üê Sin idemsg
}
```

### Error: idemsg viene null o undefined

**S√≠ntoma:**
```javascript
console.log('idemsg:', undefined);
```

**Causa:** El helper `decryptIdemsgIfNeeded()` est√° fallando al desencriptar.

**Verificaci√≥n:**
1. Buscar log: `üîì [CONTEXT-OTP] idemsg desencriptado exitosamente`
2. Si no aparece, buscar: `‚ùå [CONTEXT-OTP] Error desencriptando idemsg`

**Soluci√≥n:**
- Verificar `.env.local` tiene `VITE_AES_KEY` y `VITE_AES_IV` correctos
- Confirmar que coinciden con el backend PHP
- Reiniciar servidor Vite despu√©s de cambiar `.env.local`

### C√≥digo OTP correcto pero falla validaci√≥n

**S√≠ntoma:**
El c√≥digo SMS es correcto, pero backend dice que es inv√°lido.

**Causa:** El `codseg` no se est√° encriptando O el `idemsg` est√° mal.

**Verificaci√≥n:**
1. Log `[ENCRYPT_REQUEST]` debe mostrar:
   - `codseg: "xxxxxx=="` (encriptado) ‚úÖ
   - `idemsg: "202501251430001"` (NO encriptado) ‚úÖ

**Soluci√≥n:**
- `codseg` DEBE estar en `encryptFields`
- `idemsg` NO debe estar en `encryptFields`

---

## ÔøΩüìù Proceso de Bloqueo/Eliminaci√≥n de Usuario

### Flujo Identificado

**‚ö†Ô∏è IMPORTANTE:** No existe un proceso de "eliminar usuario" real. El sistema usa **bloqueo mediante cambio de contrase√±a temporal**.

### API Involucrada

**Proceso 2160:** `UPDATE_PASSWORD`

#### Campos Encriptados (ya configurados en fieldMapper.js)
```javascript
'2160': {
  description: 'Actualizar/Registrar contrase√±a y Validar c√≥digo 2FA',
  encryptFields: [
    'idecl', 'identificacion',           // Usuario
    'usr', 'pwd', 'clave', 'claveNueva', // Contrase√±as
    'codseg', 'codigo', 'idemsg',        // OTP (‚úÖ incluye idemsg)
    'detrsp', 'respuesta'                // Seguridad
  ],
  decryptFields: []
}
```

### M√©todo en apiService.js

```javascript
async updatePasswordWithCode({ cedula, usuario, idemsg, codigo }) {
  console.log('üîê [FORGOT] Actualizando contrase√±a con c√≥digo');

  const updateData = {
    prccode: this.processCodes.UPDATE_PASSWORD,  // '2160'
    idecl: cedula.trim(),
    usr: usuario.trim(),
    pwd: "AAAAA012345",  // ‚úÖ Contrase√±a temporal fija para bloqueo
    idemsg: idemsg.trim(),  // ‚úÖ Ya viene desencriptado gracias a la soluci√≥n
    codseg: codigo.trim()
  };

  const result = await this.makeRequest(updateData);
  // ... manejo de respuesta
}
```

### ‚úÖ Verificaci√≥n de Funcionamiento

1. **OTP Request (2155):** 
   - Backend retorna `idemsg` encriptado
   - `requestSecurityCode()` desencripta autom√°ticamente con helper
   - Frontend recibe `idemsg` desencriptado

2. **Password Update (2160):**
   - Frontend env√≠a `idemsg` desencriptado + `codseg`
   - `encryptRequest()` encripta AMBOS campos antes de enviar
   - Backend recibe y valida correctamente ‚úÖ

**Conclusi√≥n:** El proceso de bloqueo/eliminaci√≥n YA FUNCIONA correctamente con la soluci√≥n implementada.

---

## ‚úÖ Testing y Validaci√≥n

### Casos de Prueba Recomendados

#### 1. Transferencia Interna
```
1. Login ‚Üí Dashboard ‚Üí Transferencias ‚Üí Entre mis cuentas
2. Seleccionar cuenta origen y destino
3. Ingresar monto ‚Üí Solicitar OTP
4. Verificar en consola: "üîì [INTERNAL-TRANSFER-OTP] idemsg desencriptado"
5. Ingresar c√≥digo OTP de 6 d√≠gitos
6. Confirmar transferencia exitosa ‚úÖ
```

#### 2. Transferencia Cooperativa
```
1. Dashboard ‚Üí Transferencias ‚Üí A usuario CACVIL
2. Seleccionar beneficiario
3. Solicitar OTP
4. Verificar log: "üîì [COOP-TRANSFER-OTP] idemsg desencriptado"
5. Validar c√≥digo ‚Üí Transferencia exitosa ‚úÖ
```

#### 3. Autenticaci√≥n 2FA
```
1. Login con c√©dula/contrase√±a
2. Sistema solicita OTP autom√°ticamente
3. Verificar log: "üîì [2FA-OTP] idemsg desencriptado"
4. Ingresar c√≥digo ‚Üí Acceso exitoso ‚úÖ
```

#### 4. Cambio de Contrase√±a
```
1. Dashboard ‚Üí Configuraci√≥n ‚Üí Cambiar contrase√±a
2. Solicitar c√≥digo OTP
3. Verificar log: "üîì [CHANGE-PWD-OTP] idemsg desencriptado"
4. Ingresar c√≥digo + nueva contrase√±a ‚Üí Cambio exitoso ‚úÖ
```

#### 5. Bloqueo de Usuario
```
1. Desde login ‚Üí "¬øOlvidaste tu contrase√±a?" ‚Üí Bloquear usuario
2. Ingresar c√©dula y respuesta de seguridad
3. Sistema solicita OTP (usa requestSecurityCode)
4. Ingresar c√≥digo ‚Üí Usuario bloqueado ‚úÖ
```

### Verificaci√≥n en Console

**Buscar estos logs en orden:**
```
üì® [CONTEXT] Solicitando c√≥digo OTP para transferencia
‚úÖ [CONTEXT] C√≥digo OTP solicitado exitosamente
üîì [CONTEXT-OTP] idemsg desencriptado exitosamente  ‚Üê ‚úÖ CLAVE
üÜî [CONTEXT] idemsg procesado
```

---

## üìö Referencias

### Documentaci√≥n Relacionada

- **`ENCRYPTION_IMPLEMENTATION_SPRINT1.md`** - Sistema de encriptaci√≥n base
- **`BACKEND_ENCRYPTION_GUIDE.md`** - Gu√≠a de compatibilidad con backend PHP
- **`CONTACTOS_BENEFICIARIOS_ENCRYPTION_FIX.md`** - Fix previo similar (c√≥digos de cat√°logo)

### Archivos Clave del Sistema

```
src/
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ apiService.js                  (5,989 ‚Üí 6,262 l√≠neas) ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ apiserviceTransfer.js          (982 ‚Üí 1,012 l√≠neas) ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ ApiServiceTransferExt.js       (835 ‚Üí 865 l√≠neas) ‚úÖ
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ crypto/
‚îÇ       ‚îú‚îÄ‚îÄ encryptionService.js       (decrypt function)
‚îÇ       ‚îú‚îÄ‚îÄ fieldMapper.js             (2160 config ‚úÖ)
‚îÇ       ‚îî‚îÄ‚îÄ constants.js               (AES_KEY, AES_IV)
‚îî‚îÄ‚îÄ components/
    ‚îú‚îÄ‚îÄ BlockUser.jsx                  (Flujo de bloqueo)
    ‚îî‚îÄ‚îÄ CodigoPage.jsx                 (Validaci√≥n OTP)
```

---

## üéØ Pr√≥ximos Pasos

### Mejoras Futuras (Opcional)

1. **Refactorizaci√≥n DRY:**
   - Crear un √∫nico helper method en clase base compartida
   - Evitar duplicaci√≥n en los 3 servicios

2. **Testing Automatizado:**
   - Unit tests para `decryptIdemsgIfNeeded()`
   - Integration tests para flujos OTP completos

3. **Monitoreo:**
   - Agregar m√©tricas de fallos de desencriptaci√≥n
   - Dashboard de errores OTP

4. **Documentaci√≥n Backend:**
   - Confirmar con equipo backend que `idemsg` siempre viene encriptado
   - Documentar excepciones si las hay

---

## üë®‚Äçüíª Autor y Fechas

**Implementaci√≥n:** Enero 2025  
**√öltima actualizaci√≥n:** 26/01/2025  
**Versi√≥n:** 1.0.0  

**Patr√≥n aplicado:** Desencriptaci√≥n transparente en capa de servicios (similar a fix de c√≥digos de cat√°logo en beneficiarios)

---

## üèÜ Resultado Final

‚úÖ **7 m√©todos OTP corregidos** en 3 servicios  
‚úÖ **3 helpers methods** agregados (1 por servicio)  
‚úÖ **Todos los flujos OTP funcionando:** Transferencias, 2FA, cambio pwd, registro, bloqueo  
‚úÖ **Proceso de bloqueo/eliminaci√≥n usuario:** Verificado funcionando correctamente  
‚úÖ **Sistema robusto:** Manejo de errores con fallback  
‚úÖ **Logging completo:** Debugging facilitado con contextos espec√≠ficos  

**üéâ MISI√ìN CUMPLIDA: Sistema de transferencias y OTP completamente operativo**
